/*
 * FlexiLocale - An easy generation Android i18ns string call Gradle plugin.
 * Copyright (C) 2019 HighCapable
 * https://github.com/BetterAndroid/FlexiLocale
 *
 * Apache License Version 2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file is created by fankes on 2023/10/10.
 */
package com.highcapable.flexilocale.plugin.generator

import com.highcapable.flexilocale.FlexiLocale
import com.highcapable.flexilocale.plugin.config.proxy.IFlexiLocaleConfigs
import com.highcapable.flexilocale.plugin.generator.factory.LocaleStringMap
import com.highcapable.flexilocale.utils.debug.FError
import com.highcapable.flexilocale.utils.factory.camelcase
import com.highcapable.flexilocale.utils.factory.uppercamelcase
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.abs

/**
 * I18ns 生成工具类
 */
internal class LocaleSourcesGenerator {

    /**
     * 生成 [FileSpec]
     * @param configs 当前配置
     * @param keyValues 键值数组
     * @param namespace 命名空间
     * @param packageName 包名
     * @return [FileSpec]
     * @throws IllegalStateException 如果生成失败
     */
    internal fun build(
        configs: IFlexiLocaleConfigs,
        keyValues: LocaleStringMap,
        namespace: String,
        packageName: String
    ) = runCatching {
        FileSpec.builder(packageName, configs.className).apply {
            val selfClass = ClassName(packageName, configs.className)
            val contextClass = ClassName("android.content", "Context")
            val resourcesClass = ClassName("android.content.res", "Resources")
            val resourcesInitializer = LambdaTypeName.get(returnType = resourcesClass, parameters = emptyList())
            addAnnotation(AnnotationSpec.builder(Suppress::class).addMember("\"StringFormatInvalid\"").build())
            addImport(namespace, "R")
            addType(TypeSpec.classBuilder(selfClass).apply {
                addKdoc(
                    """
                      This class is generated by ${FlexiLocale.TAG} at ${SimpleDateFormat.getDateTimeInstance().format(Date())}
                      
                      The content here is automatically generated according to the res/values of your projects
                      
                      You can visit [here](${FlexiLocale.PROJECT_URL}) for more help
                    """.trimIndent()
                )
                if (configs.isEnableRestrictedAccess) addModifiers(KModifier.INTERNAL)
                addFunction(FunSpec.constructorBuilder().addModifiers(KModifier.PRIVATE).build())
                addProperty(PropertySpec.builder("context", contextClass.copy(nullable = true)).apply {
                    addKdoc("The current [Context] for this app or library")
                    addModifiers(KModifier.PRIVATE)
                    mutable()
                    initializer("null")
                }.build())
                addProperty(PropertySpec.builder("resources", resourcesClass.copy(nullable = true)).apply {
                    addKdoc("The current [Resources] for this app or library")
                    addModifiers(KModifier.PRIVATE)
                    mutable()
                    initializer("null")
                }.build())
                addProperty(PropertySpec.builder("resourcesInitializer", resourcesInitializer.copy(nullable = true)).apply {
                    addKdoc("The current [Resources] initializer for this app or library")
                    addModifiers(KModifier.PRIVATE)
                    mutable()
                    initializer("null")
                }.build())
                addType(TypeSpec.companionObjectBuilder().apply {
                    if (configs.isEnableRestrictedAccess) addModifiers(KModifier.INTERNAL)
                    addFunction(FunSpec.builder("attach").apply {
                        addKdoc(
                            """
                              Attach [${selfClass.simpleName}] to [Context]
                              @param context like [android.app.Application] or [android.app.Activity]
                              @return [${selfClass.simpleName}]
                            """.trimIndent()
                        )
                        addAnnotation(JvmStatic::class)
                        if (configs.isEnableRestrictedAccess) addModifiers(KModifier.INTERNAL)
                        addParameter("context", contextClass)
                        addStatement("return ${selfClass.simpleName}().apply { this.context = context }")
                        returns(selfClass)
                    }.build())
                    addFunction(FunSpec.builder("attach").apply {
                        addKdoc(
                            """
                              Attach [${selfClass.simpleName}] to [Resources]
                              
                              - Note: this method will have no effect if [context] already exists
                              @param resources A [Resources] that exists and has not been recycled
                              @return [${selfClass.simpleName}]
                            """.trimIndent()
                        )
                        addAnnotation(JvmStatic::class)
                        if (configs.isEnableRestrictedAccess) addModifiers(KModifier.INTERNAL)
                        addParameter("resources", resourcesClass)
                        addStatement("return ${selfClass.simpleName}().apply { this.resources = resources }")
                        returns(selfClass)
                    }.build())
                    addFunction(FunSpec.builder("attach").apply {
                        addKdoc(
                            """
                              Attach [${selfClass.simpleName}] to [Resources] initializer
                              
                              - Note: this method will have no effect if [context] already exists
                              @param resourcesInitializer A [Resources] initializer returns a non-recycled instance
                              @return [${selfClass.simpleName}]
                            """.trimIndent()
                        )
                        addAnnotation(JvmStatic::class)
                        if (configs.isEnableRestrictedAccess) addModifiers(KModifier.INTERNAL)
                        addParameter("resourcesInitializer", resourcesInitializer)
                        addStatement("return ${selfClass.simpleName}().apply { this.resourcesInitializer = resourcesInitializer }")
                        returns(selfClass)
                    }.build())
                }.build())
                addProperty(PropertySpec.builder("currentResources", resourcesClass).apply {
                    addKdoc("The current used [Resources] for this app or library")
                    addModifiers(KModifier.PRIVATE)
                    getter(FunSpec.getterBuilder().apply {
                        addStatement("return context?.resources ?: resourcesInitializer?.invoke() ?: resources" +
                            "?: error(\"${("Unable to get Resource instance, the app may have been killed " +
                                "or initialization process failed").toKotlinPoetSpace()}\")")
                    }.build())
                }.build())
                keyValues.forEach { (key, contentValues) ->
                    val fixedKey = key.camelcase()
                    val getterKey = "get${key.uppercamelcase()}"
                    val statement = "return currentResources.getString(R.string.$key, *formatArgs)"
                    var kDoc = "Resolve the [R.string.$key]\n\n"
                    if (contentValues.isNotEmpty()) kDoc += "| Configuration | Value |\n| --- | --- |\n"
                    contentValues.toList()
                        .sortedWith(compareBy<Pair<String, String>> { it.first != "default" }.thenBy { it.first })
                        .toAutoWrapKeyValues()
                        .forEach { (key, value) ->
                            val displayValue = value.replace("%".toRegex(), "%%")
                            kDoc += "| $key | $displayValue |\n"
                        }; kDoc = kDoc.trim()
                    addProperty(PropertySpec.builder(fixedKey, String::class).apply {
                        addKdoc(kDoc)
                        if (configs.isEnableRestrictedAccess) addModifiers(KModifier.INTERNAL)
                        getter(FunSpec.getterBuilder().apply {
                            addAnnotation(AnnotationSpec.builder(JvmName::class).addMember("\"$getterKey\"").build())
                            addStatement("return $fixedKey()")
                        }.build())
                    }.build())
                    addFunction(FunSpec.builder(fixedKey).apply {
                        addKdoc("$kDoc\n@param formatArgs The format arguments that will be used for substitution")
                        addAnnotation(AnnotationSpec.builder(JvmName::class).addMember("\"$getterKey\"").build())
                        if (configs.isEnableRestrictedAccess) addModifiers(KModifier.INTERNAL)
                        addParameter(ParameterSpec.builder("formatArgs", Any::class.asTypeName()).addModifiers(KModifier.VARARG).build())
                        addStatement(statement)
                        returns(String::class)
                    }.build())
                }
            }.build())
        }.build()
    }.getOrElse { FError.make("Failed to generated Kotlin file\n$it") }

    /**
     * 转换为自动换行键值对数组
     * @return [List]<[Pair]<[String], [String]>>
     */
    private fun List<Pair<String, String>>.toAutoWrapKeyValues(): List<Pair<String, String>> {
        val maxAllowLength = 75
        val punctuations = charArrayOf('.', '。', ',', '，', '、', ';', '；', ':', '：', '!', '！', '?', '？')
        val result = mutableListOf<Pair<String, String>>()
        val placeholders = mutableListOf<Pair<String, String>>()
        forEach {
            var key = it.first
            var value = it.second.replace("\\n", "ㅤ")
            val maxLength = abs(maxAllowLength - key.length)
            while (value.length > maxLength) {
                var splitIndex = maxLength
                var splitValue = value.substring(0, splitIndex)
                val lastSpaceIndex = splitValue.lastIndexOf(' ')
                val lastPunctuationIndex = splitValue.lastIndexOfAny(punctuations)
                val hashWrapIndex = splitValue.lastIndexOf('ㅤ')
                when {
                    hashWrapIndex != -1 && (hashWrapIndex < lastSpaceIndex || hashWrapIndex < lastPunctuationIndex) -> {
                        splitIndex = hashWrapIndex
                        splitValue = value.substring(0, splitIndex)
                    }
                    lastSpaceIndex != -1 && lastSpaceIndex >= lastPunctuationIndex -> {
                        splitIndex = lastSpaceIndex + 1
                        splitValue = value.substring(0, splitIndex)
                    }
                    lastPunctuationIndex != -1 -> {
                        splitIndex = lastPunctuationIndex + 1
                        splitValue = value.substring(0, splitIndex)
                    }
                }
                value = value.substring(splitIndex).trimStart('ㅤ')
                result.add(key to splitValue)
                key = " ".repeat(key.length)
            }
            if (value.isNotEmpty())
                result.add(key to value.replace("ㅤ", ""))
            else placeholders.add(key to "")
        }; result.addAll(placeholders)
        return result
    }

    /**
     * 转换到 KotlinPoet 声明的空格
     * @return [String]
     */
    private fun String.toKotlinPoetSpace() = replace(" ", "·")
}